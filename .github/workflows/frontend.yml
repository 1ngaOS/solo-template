name: Frontend CI/CD

on:
  pull_request:
    types: [opened, synchronize, closed]
    paths:
      - 'apps/frontend/**'
      - '.github/workflows/frontend.yml'
      - 'infra/systemd/__TEMPLATE_FRONTEND_STAGING_SERVICE_FILE__'
      - 'infra/systemd/__TEMPLATE_FRONTEND_PRODUCTION_SERVICE_FILE__'
  workflow_dispatch:
    inputs:
      public_api_url:
        description: 'Public API URL'
        required: false
        default: ''

env:
  CARGO_TERM_COLOR: always

jobs:
  format:
    name: Format
    runs-on: self-hosted
    if: |
      github.event.pull_request.merged == false &&
      (github.event.pull_request.base.ref == 'main' || github.event.pull_request.base.ref == 'uat' || github.event.pull_request.base.ref == 'prod')
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Clean setup-pnpm (avoid worker.js MODULE_NOT_FOUND on self-hosted)
        run: rm -rf "$HOME/setup-pnpm"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable pnpm via Corepack
        run: corepack enable && corepack prepare pnpm@10 --activate

      - name: Ensure pnpm store path exists
        run: mkdir -p $(pnpm store path)

      - name: Add pnpm to PATH
        run: echo "PATH=$PNPM_HOME:$PATH" >> $GITHUB_ENV

      - name: Install dependencies
        run: pnpm install

      - name: Run format (normalize)
        run: pnpm frontend format
        # Normalize formatting so check passes (runner/Prettier version can differ from local; package.json often gets rewritten by tooling)

      - name: Run format check
        run: pnpm frontend format:check

      - name: Write job summary
        if: always()
        run: |
          echo "## âœ¨ Format Job Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Job:** Format" >> $GITHUB_STEP_SUMMARY
          echo "**Component:** Frontend" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Completed Steps" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Checkout repository" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Install pnpm" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Setup Node.js" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Install dependencies" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Run format (normalize)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Run format check" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Completed at:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  lint:
    name: Lint
    runs-on: self-hosted
    needs: format
    if: |
      github.event.pull_request.merged == false &&
      (github.event.pull_request.base.ref == 'main' || github.event.pull_request.base.ref == 'uat' || github.event.pull_request.base.ref == 'prod')
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Clean setup-pnpm (avoid worker.js MODULE_NOT_FOUND on self-hosted)
        run: rm -rf "$HOME/setup-pnpm"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable pnpm via Corepack
        run: corepack enable && corepack prepare pnpm@10 --activate

      - name: Ensure pnpm store path exists
        run: mkdir -p $(pnpm store path)

      - name: Add pnpm to PATH
        run: echo "PATH=$PNPM_HOME:$PATH" >> $GITHUB_ENV

      - name: Install dependencies
        run: pnpm install

      - name: Run format (normalize)
        run: pnpm frontend format
        # Normalize before lint so any Prettier check would pass; we run eslint only below

      - name: Run linter
        run: cd apps/frontend && npx eslint .
        # Use npx (from Node.js) instead of pnpm exec to avoid "pnpm: command not found" on self-hosted

      - name: Write job summary
        if: always()
        run: |
          echo "## ðŸ§¹ Lint Job Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Job:** Lint" >> $GITHUB_STEP_SUMMARY
          echo "**Component:** Frontend" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Completed Steps" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Checkout repository" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Install pnpm" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Setup Node.js" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Install dependencies" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Run format (normalize)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Run linter" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Completed at:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  check:
    name: Check
    runs-on: self-hosted
    needs: [lint]
    if: |
      github.event.pull_request.merged == false &&
      (github.event.pull_request.base.ref == 'main' || github.event.pull_request.base.ref == 'uat' || github.event.pull_request.base.ref == 'prod')
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Clean setup-pnpm (avoid worker.js MODULE_NOT_FOUND on self-hosted)
        run: rm -rf "$HOME/setup-pnpm"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable pnpm via Corepack
        run: corepack enable && corepack prepare pnpm@10 --activate

      - name: Ensure pnpm store path exists
        run: mkdir -p $(pnpm store path)

      - name: Add pnpm to PATH
        run: echo "PATH=$PNPM_HOME:$PATH" >> $GITHUB_ENV

      - name: Install dependencies
        run: pnpm install

      - name: Run type check
        run: pnpm frontend check

      - name: Write job summary
        if: always()
        run: |
          echo "## âœ… Check Job Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Job:** Check" >> $GITHUB_STEP_SUMMARY
          echo "**Component:** Frontend" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Completed Steps" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Checkout repository" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Install pnpm" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Setup Node.js" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Install dependencies" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Run type check" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Completed at:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  test:
    name: Test
    runs-on: self-hosted
    needs: [check]
    if: github.event.pull_request.merged == false
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Clean setup-pnpm (avoid worker.js MODULE_NOT_FOUND on self-hosted)
        run: rm -rf "$HOME/setup-pnpm"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable pnpm via Corepack
        run: corepack enable && corepack prepare pnpm@10 --activate

      - name: Ensure pnpm store path exists
        run: mkdir -p $(pnpm store path)

      - name: Add pnpm to PATH
        run: echo "PATH=$PNPM_HOME:$PATH" >> $GITHUB_ENV

      - name: Install dependencies
        run: pnpm install

      - name: Install Playwright browsers
        run: pnpm --filter frontend exec playwright install --with-deps chromium

      - name: Build frontend (for test server)
        working-directory: apps/frontend
        run: pnpm exec svelte-kit sync && pnpm run build

      - name: Set test port
        id: test-port
        run: echo "port=$(( 30000 + (${{ github.run_id }} % 10000) ))" >> $GITHUB_OUTPUT

      - name: Run tests
        env:
          CI: 'true'
          MOCK_API: 'true'
          CI_USE_PREBUILT: 'true'
          PLAYWRIGHT_TEST_PORT: ${{ steps.test-port.outputs.port }}
        run: pnpm frontend test

      - name: Upload Playwright report
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: apps/frontend/playwright-report/
          retention-days: 7
          if-no-files-found: ignore

      - name: Write job summary
        if: always()
        run: |
          echo "## âœ… Test Job Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Job:** Test" >> $GITHUB_STEP_SUMMARY
          echo "**Component:** Frontend" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Completed Steps" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Checkout repository" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Install pnpm" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Setup Node.js" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Install dependencies" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Install Playwright (Chromium)" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Run Playwright tests" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Completed at:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  version:
    name: Bump Version
    runs-on: self-hosted
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Clean setup-pnpm (avoid worker.js MODULE_NOT_FOUND on self-hosted)
        run: rm -rf "$HOME/setup-pnpm"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable pnpm via Corepack
        run: corepack enable && corepack prepare pnpm@10 --activate

      - name: Add pnpm to PATH
        run: echo "PATH=$PNPM_HOME:$PATH" >> $GITHUB_ENV

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Pull latest changes
        run: |
          git fetch origin ${{ github.event.pull_request.base.ref }}
          git checkout ${{ github.event.pull_request.base.ref }}
          git pull origin ${{ github.event.pull_request.base.ref }} --rebase || git pull origin ${{ github.event.pull_request.base.ref }} --no-rebase

      - name: Get current version from package.json
        id: current_version
        working-directory: apps/frontend
        run: |
          VERSION=$(node -p "require('./package.json').version")
          if [ -z "$VERSION" ]; then
            echo "Error: Version is empty in package.json"
            exit 1
          fi
          echo "current_version=$VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $VERSION"

      - name: Bump version in package.json
        id: new_version
        working-directory: apps/frontend
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.current_version }}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
          node -e "
            const fs = require('fs');
            const p = 'package.json';
            const j = JSON.parse(fs.readFileSync(p, 'utf8'));
            j.version = '$NEW_VERSION';
            fs.writeFileSync(p, JSON.stringify(j, null, 2) + '\n');
          "
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      - name: Commit version changes
        run: |
          git add apps/frontend/package.json
          if git diff --staged --quiet; then
            echo "No version changes to commit"
          else
            git commit -m "chore(frontend): bump version to ${{ steps.new_version.outputs.new_version }} [skip ci]"
          fi

      - name: Create git tag
        run: |
          if git rev-parse "frontend-v${{ steps.new_version.outputs.new_version }}" >/dev/null 2>&1; then
            echo "Tag frontend-v${{ steps.new_version.outputs.new_version }} already exists"
          else
            git tag -a "frontend-v${{ steps.new_version.outputs.new_version }}" -m "Release frontend v${{ steps.new_version.outputs.new_version }}"
          fi

      - name: Push changes and tags
        run: |
          set -e
          BRANCH="${{ github.event.pull_request.base.ref }}"
          PUSHED=
          for _ in 1 2 3; do
            git fetch origin "$BRANCH"
            git checkout "$BRANCH"
            git pull origin "$BRANCH" --rebase || git pull origin "$BRANCH" --no-rebase
            if [ -z "$(git log origin/$BRANCH..HEAD 2>/dev/null)" ]; then
              echo "No new commits to push"
              PUSHED=1
              break
            fi
            if git push origin HEAD:"$BRANCH" --force-with-lease || git push origin HEAD:"$BRANCH"; then
              PUSHED=1
              break
            fi
            echo "Push rejected (remote moved), retrying after pull..."
          done
          if [ -z "$PUSHED" ]; then
            echo "ERROR: Failed to push after 3 attempts"
            exit 1
          fi
          git push origin --tags || true

      - name: Write job summary
        if: always()
        run: |
          echo "## ðŸ“¦ Version Bump Job Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Job:** Bump Version" >> $GITHUB_STEP_SUMMARY
          echo "**Component:** Frontend" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Version Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Current Version:** ${{ steps.current_version.outputs.current_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **New Version:** ${{ steps.new_version.outputs.new_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.event.pull_request.base.ref }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Completed at:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  build:
    name: Build
    runs-on: self-hosted
    needs: version
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Pull latest changes (including version bump)
        run: |
          git fetch origin ${{ github.event.pull_request.base.ref }}
          git checkout ${{ github.event.pull_request.base.ref }}
          git pull origin ${{ github.event.pull_request.base.ref }} --rebase || git pull origin ${{ github.event.pull_request.base.ref }} --no-rebase

      - name: Clean setup-pnpm (avoid worker.js MODULE_NOT_FOUND on self-hosted)
        run: rm -rf "$HOME/setup-pnpm"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Enable pnpm via Corepack
        run: corepack enable && corepack prepare pnpm@10 --activate

      - name: Ensure pnpm store path exists
        run: mkdir -p $(pnpm store path)

      - name: Add pnpm to PATH
        run: echo "PATH=$PNPM_HOME:$PATH" >> $GITHUB_ENV

      - name: Install dependencies
        run: pnpm install

      - name: Get version from package.json
        id: version
        working-directory: apps/frontend
        run: |
          VERSION=$(node -p "require('./package.json').version")
          if [ -z "$VERSION" ]; then
            echo "Error: Version is empty in package.json"
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      # Frontend build: same as deploy â€“ set repo secret PUBLIC_API_URL or leave empty.
      - name: Set build env
        run: |
          api_key="VITE_API_URL"
          version_key="VITE_APP_VERSION"
          if [ -n "$API_URL_INPUT" ]; then
            echo "${api_key}=$API_URL_INPUT" >> "$GITHUB_ENV"
          else
            echo "${api_key}=" >> "$GITHUB_ENV"
          fi
          echo "${version_key}=$VERSION_FOR_BUILD" >> "$GITHUB_ENV"
        env:
          API_URL_INPUT: ${{ secrets.PUBLIC_API_URL }}
          VERSION_FOR_BUILD: ${{ steps.version.outputs.version }}

      - name: Build
        run: pnpm frontend build

      - name: Verify build output exists
        working-directory: apps/frontend
        run: |
          if [ ! -d "build" ]; then
            echo "Error: Build directory 'build' does not exist"
            echo "Build output:"
            ls -la . || true
            exit 1
          fi
          echo "Build directory exists:"
          ls -la build/ | head -20

      - name: Determine deployment environment
        id: env
        run: |
          BRANCH="${{ github.event.pull_request.base.ref }}"
          APP_NAME="__TEMPLATE_DEPLOY_APP_NAME__"
          if [ "$BRANCH" = "prod" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "service_file=__TEMPLATE_FRONTEND_PRODUCTION_SERVICE_FILE__" >> $GITHUB_OUTPUT
            echo "deploy_dir=/opt/${APP_NAME}/frontend/production" >> $GITHUB_OUTPUT
            echo "port=__TEMPLATE_FRONTEND_PRODUCTION_PORT__" >> $GITHUB_OUTPUT
            echo "api_port=__TEMPLATE_BACKEND_PRODUCTION_PORT__" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "service_file=__TEMPLATE_FRONTEND_STAGING_SERVICE_FILE__" >> $GITHUB_OUTPUT
            echo "deploy_dir=/opt/${APP_NAME}/frontend/staging" >> $GITHUB_OUTPUT
            echo "port=__TEMPLATE_FRONTEND_STAGING_PORT__" >> $GITHUB_OUTPUT
            echo "api_port=__TEMPLATE_BACKEND_STAGING_PORT__" >> $GITHUB_OUTPUT
          fi
          echo "Deploying to: ${{ steps.env.outputs.environment }}"
          echo "Service file: ${{ steps.env.outputs.service_file }}"
          echo "Deploy directory: ${{ steps.env.outputs.deploy_dir }}"
          echo "Port: ${{ steps.env.outputs.port }}"
          echo "API Port: ${{ steps.env.outputs.api_port }}"

      - name: Package frontend for VM deploy
        run: |
          mkdir -p deploy/frontend
          cp -r apps/frontend/build deploy/frontend/build
          cp apps/frontend/package.json deploy/frontend/
          cp apps/frontend/serve.mjs deploy/frontend/
          cp infra/systemd/${{ steps.env.outputs.service_file }} deploy/frontend/frontend.service
          tar -czvf frontend-deploy.tar.gz -C deploy frontend

      - name: Upload deploy artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-deploy-v${{ steps.version.outputs.version }}
          path: frontend-deploy.tar.gz
          retention-days: 1

      - name: Write job summary
        if: always()
        run: |
          echo "## ðŸ—ï¸ Build Job Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Job:** Build" >> $GITHUB_STEP_SUMMARY
          echo "**Component:** Frontend" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Build Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch:** ${{ github.event.pull_request.base.ref }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Completed Steps" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Checkout repository" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Pull latest changes" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Install pnpm" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Setup Node.js" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Install dependencies" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Build" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Package deploy tarball" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Upload artifact" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Completed at:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  get-version:
    name: Get Version
    runs-on: self-hosted
    needs: [version, build]
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version from package.json
        id: version
        run: |
          git fetch origin ${{ github.event.pull_request.base.ref }}
          git checkout origin/${{ github.event.pull_request.base.ref }} -- apps/frontend/package.json
          VERSION=$(node -p "require('./apps/frontend/package.json').version")
          if [ -z "$VERSION" ]; then
            echo "Error: Version is empty in package.json"
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Release version: $VERSION"

      - name: Write job summary
        if: always()
        run: |
          echo "## ðŸ“‹ Get Version Job Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Job:** Get Version" >> $GITHUB_STEP_SUMMARY
          echo "**Component:** Frontend" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Version Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Completed at:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  deploy:
    name: Deploy (systemd)
    runs-on: self-hosted
    needs: [get-version, build]
    environment: ${{ github.event.pull_request.base.ref == 'prod' && 'production' || 'staging' }}
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true &&
      (github.event.pull_request.base.ref == 'main' || github.event.pull_request.base.ref == 'prod')
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download frontend artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-deploy-v${{ needs.get-version.outputs.version }}
          merge-multiple: false

      # Deploy uses frontend-deploy.tar.gz from the build job (not apps/frontend/out).
      - name: Verify deploy artifact
        run: |
          TAR=""
          if [ -f "frontend-deploy.tar.gz" ]; then
            TAR="frontend-deploy.tar.gz"
          else
            TAR=$(find . -name "frontend-deploy.tar.gz" -type f 2>/dev/null | head -1)
            if [ -n "$TAR" ]; then
              cp "$TAR" frontend-deploy.tar.gz
              TAR="frontend-deploy.tar.gz"
            fi
          fi
          if [ -z "$TAR" ] || [ ! -f "$TAR" ]; then
            echo "Error: frontend-deploy.tar.gz was not downloaded (deploy expects the deploy tarball, not apps/frontend/out)."
            echo "Contents of workspace:"
            ls -la
            find . -maxdepth 3 -type f -name "*.tar.gz" 2>/dev/null || true
            exit 1
          fi
          echo "Deploy artifact OK:"
          ls -lh frontend-deploy.tar.gz
          tar -tzf frontend-deploy.tar.gz | head -15

      - name: Determine deployment environment (deploy step)
        id: deploy_env
        run: |
          BRANCH="${{ github.event.pull_request.base.ref }}"
          APP_NAME="${{ secrets.VM_APP_NAME || '__TEMPLATE_DEPLOY_APP_NAME__' }}"
          if [ "$BRANCH" = "prod" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "deploy_dir=/opt/${APP_NAME}/frontend/production" >> $GITHUB_OUTPUT
            echo "port=__TEMPLATE_FRONTEND_PRODUCTION_PORT__" >> $GITHUB_OUTPUT
            echo "api_port=__TEMPLATE_BACKEND_PRODUCTION_PORT__" >> $GITHUB_OUTPUT
            echo "service_name=__TEMPLATE_SYSTEMD_FRONTEND_PRODUCTION__" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "deploy_dir=/opt/${APP_NAME}/frontend/staging" >> $GITHUB_OUTPUT
            echo "port=__TEMPLATE_FRONTEND_STAGING_PORT__" >> $GITHUB_OUTPUT
            echo "api_port=__TEMPLATE_BACKEND_STAGING_PORT__" >> $GITHUB_OUTPUT
            echo "service_name=__TEMPLATE_SYSTEMD_FRONTEND_STAGING__" >> $GITHUB_OUTPUT
          fi

      - name: Create frontend .env for VM
        run: |
          API_URL="${{ secrets.PUBLIC_API_URL }}"
          if [ -z "$API_URL" ]; then
            API_URL="http://127.0.0.1:${{ steps.deploy_env.outputs.api_port }}"
          fi
          printf 'PUBLIC_API_URL=%s\n' "$API_URL" > frontend.env

      - name: Copy frontend to VM
        uses: appleboy/scp-action@v1
        with:
          host: ${{ secrets.VM_IP }}
          username: ${{ secrets.VM_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.VM_SSH_PORT || 22 }}
          source: "frontend-deploy.tar.gz,frontend.env"
          target: "/tmp/__TEMPLATE_DEPLOY_APP_NAME__-deploy/"

      - name: Install and restart frontend systemd service
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.VM_IP }}
          username: ${{ secrets.VM_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          port: ${{ secrets.VM_SSH_PORT || 22 }}
          script: |
            set -e
            DEPLOY_DIR="${{ steps.deploy_env.outputs.deploy_dir }}"
            SERVICE_NAME="${{ steps.deploy_env.outputs.service_name }}"
            ENV_NAME="${{ steps.deploy_env.outputs.environment }}"
            
            echo "=== Deploying to $ENV_NAME environment ==="
            echo "Deploy directory: $DEPLOY_DIR"
            echo "Service name: $SERVICE_NAME"
            
            echo "=== Stopping frontend service (prevents restart loop during deploy) ==="
            sudo systemctl stop "$SERVICE_NAME" || true
            
            sudo mkdir -p "$DEPLOY_DIR"
            cd /tmp/__TEMPLATE_DEPLOY_APP_NAME__-deploy && tar -xzf frontend-deploy.tar.gz
            sudo rm -rf "$DEPLOY_DIR/build"
            sudo cp -r /tmp/__TEMPLATE_DEPLOY_APP_NAME__-deploy/frontend/build "$DEPLOY_DIR/"
            sudo install -m 644 /tmp/__TEMPLATE_DEPLOY_APP_NAME__-deploy/frontend/package.json "$DEPLOY_DIR/"
            sudo install -m 755 /tmp/__TEMPLATE_DEPLOY_APP_NAME__-deploy/frontend/serve.mjs "$DEPLOY_DIR/"
            sudo chown -R www-data:www-data "$DEPLOY_DIR"
            sudo cp /tmp/__TEMPLATE_DEPLOY_APP_NAME__-deploy/frontend.env "$DEPLOY_DIR/.env"
            sudo chown www-data:www-data "$DEPLOY_DIR/.env"
            sudo chmod 600 "$DEPLOY_DIR/.env"
            sudo install -m 644 /tmp/__TEMPLATE_DEPLOY_APP_NAME__-deploy/frontend/frontend.service "/etc/systemd/system/$SERVICE_NAME"
            sudo systemctl daemon-reload
            sudo systemctl enable "$SERVICE_NAME"
            sudo systemctl restart "$SERVICE_NAME"
            sudo systemctl status "$SERVICE_NAME" --no-pager || true

      - name: Deployment Summary
        if: always()
        run: |
          ENV_NAME="${{ steps.deploy_env.outputs.environment }}"
          DEPLOY_DIR="${{ steps.deploy_env.outputs.deploy_dir }}"
          PORT="${{ steps.deploy_env.outputs.port }}"
          
          echo "### ðŸ” Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Component:** Frontend (systemd)" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** $ENV_NAME" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.get-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deploy Directory:** \`$DEPLOY_DIR\`" >> $GITHUB_STEP_SUMMARY
          echo "**Port:** $PORT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Steps" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Download frontend artifact" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Copy to VM" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Install and restart \`${{ steps.deploy_env.outputs.service_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Completed at:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  release:
    name: Create Release
    runs-on: self-hosted
    needs: [get-version, deploy]
    if: |
      github.event_name == 'pull_request' &&
      github.event.action == 'closed' &&
      github.event.pull_request.merged == true
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-deploy-v${{ needs.get-version.outputs.version }}
          merge-multiple: false

      - name: Create GitHub Release
        run: |
          echo "Release placeholder â€“ attach frontend-deploy.tar.gz or use softprops/action-gh-release if needed"

      - name: Write job summary
        if: always()
        run: |
          echo "## ðŸš€ Release Job Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Job:** Create Release" >> $GITHUB_STEP_SUMMARY
          echo "**Component:** Frontend" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Release Information" >> $GITHUB_STEP_SUMMARY
          echo "- **Version:** ${{ needs.get-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tag:** frontend-v${{ needs.get-version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Completed at:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY

  monitor-failures:
    name: Monitor Failed Jobs
    runs-on: self-hosted
    if: failure()
    needs: [format, lint, check, test, version, build, get-version, deploy, release]
    permissions:
      contents: read
      issues: write
      actions: read
    steps:
      - uses: actions/checkout@v4

      - name: Create failure issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: run } = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const { data: jobsData } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId
            });
            const failedJobs = jobsData.jobs.filter(job =>
              job.conclusion === 'failure' || job.conclusion === 'cancelled' || job.conclusion === 'timed_out'
            );
            if (failedJobs.length === 0) return;

            const branch = context.ref.replace('refs/heads/', '');
            const title = `ðŸš¨ CI/CD Failure: Frontend - ${branch} branch`;
            let body = `## CI/CD Pipeline Failure\n\n`;
            body += `**Workflow:** [Frontend](${run.html_url})\n`;
            body += `**Branch:** \`${branch}\`\n`;
            body += `**Commit:** [${context.sha.substring(0, 7)}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/commit/${context.sha})\n`;
            body += `**Triggered by:** @${context.actor}\n`;
            body += `**Started:** ${new Date(run.created_at).toISOString()}\n`;
            body += `**Status:** ${run.status} / ${run.conclusion}\n\n`;
            body += `### Failed Jobs (${failedJobs.length})\n\n`;
            for (const job of failedJobs) {
              body += `#### âŒ ${job.name}\n\n`;
              body += `- **Status:** ${job.conclusion}\n`;
              body += `- **Job URL:** [View Job](${job.html_url})\n`;
              body += `- **Started:** ${job.started_at ? new Date(job.started_at).toISOString() : 'N/A'}\n`;
              body += `- **Completed:** ${job.completed_at ? new Date(job.completed_at).toISOString() : 'N/A'}\n`;
              const failedSteps = (job.steps || []).filter(s => s.conclusion === 'failure' || s.conclusion === 'cancelled' || s.conclusion === 'timed_out');
              if (failedSteps.length > 0) {
                body += `- **Failed Steps:**\n`;
                failedSteps.forEach(s => { body += `  - [\`${s.name}\`](${job.html_url}#step:${s.number}:1) (Step ${s.number}) - ${s.conclusion}\n`; });
              }
              body += `\n`;
            }
            body += `### Workflow Context\n\n`;
            body += `- **Workflow Run ID:** ${context.runId}\n`;
            body += `- **Workflow Name:** ${run.name || 'Frontend'}\n`;
            body += `- **Event:** ${context.eventName}\n`;
            if (context.payload && context.payload.pull_request) {
              body += `- **PR:** [${context.payload.pull_request.title}](${context.payload.pull_request.html_url})\n`;
            }
            body += `\n`;
            body += `### Next Steps\n\n`;
            body += `1. Review the failed job logs using the links above\n`;
            body += `2. Check for common issues: dependency install, lint/format, type check, Playwright tests, build, deploy\n`;
            body += `3. Fix the issue and push a new commit\n`;
            body += `4. Close this issue once the pipeline passes\n\n`;
            body += `### Related Links\n\n`;
            body += `- [Workflow Run](${run.html_url})\n`;
            body += `- [Commit](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/commit/${context.sha})\n`;
            body += `- [Branch](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/tree/${branch})\n\n`;
            body += `---\n`;
            body += `*This issue was automatically created by the CI/CD monitoring system.*\n`;
            body += `*Workflow: \`.github/workflows/frontend.yml\`*\n`;

            let milestone = (await github.rest.issues.listMilestones({ owner: context.repo.owner, repo: context.repo.repo, state: 'open' })).data.find(m => m.title === 'CI/CD Failures');
            if (!milestone) {
              const created = await github.rest.issues.createMilestone({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'CI/CD Failures',
                description: 'Track all CI/CD pipeline failures across the repository',
                state: 'open'
              });
              milestone = created.data;
            }

            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'ci-failure,frontend'
            });
            const existing = issues.find(i => i.title === title || i.title.includes(`Frontend - ${branch}`));
            if (existing) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existing.number,
                body,
                state: 'open',
                milestone: milestone.number
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels: ['ci-failure', 'frontend', 'bug', 'priority-high'],
                milestone: milestone.number
              });
            }

      - name: Write job summary
        if: always()
        run: |
          echo "## ðŸ” Failure Monitoring Job Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Job:** Monitor Failed Jobs" >> $GITHUB_STEP_SUMMARY
          echo "**Component:** Frontend" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Note:** This job runs only when other jobs fail." >> $GITHUB_STEP_SUMMARY
          echo "**Completed at:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
